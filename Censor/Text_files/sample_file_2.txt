As you might have guessed from the title, this is a book about Zynq! That’s Zynq as in the new generation of All-Programmable System-on-Chip (SoC) [10], not to be confused with zinc, or Zn, the chemical element.
In fact, there is a link between the two. Rumour has it that Xilinx gave their new device the name Zynq, because it represents a (processing) element that can be applied to anything. Zynq devices are intended to be flexible and form a compelling platform for a wide variety of applications, just as the metal zinc can be mixed with various other metals to form alloys with differing desirable properties.
The defining feature of Zynq is that it combines a dual-core ARM Cortex-A9 processor [1] with traditional Field Programmable Gate Array (FPGA) logic fabric. Although dedicated processors have been coupled with FPGAs before, it has never been quite the same proposition. In Zynq, the ARM Cortex-A9 is an application grade processor, capable of running full operating systems such as Linux, while the programmable logic is based on Xilinx 7-series FPGA architecture [5], [7]. The architecture is completed by industry standard AXI interfaces, which provide high bandwidth, low latency connections between the two parts of the device [8]. This means that the processor and logic can each be used for what they do best, without the overhead of interfacing between two physically separate devices. Meanwhile, benefits arising from simplifying the system to a single chip include reductions in physical size and overall cost.
As will be evident from the very size of this book, Zynq is about more than just the silicon. It is compelling because the software development tools, design flow, and standards-focussed integration methods are tailored to the requirements of Zynq-based system design [6]. The facility to create better designs more quickly is of interest to everyone! This book will introduce all of the topics necessary to get started in earnest, and also provide some practical tutorials to guide new users through the design flow and procedures.
We hope that you find the book informative and useful, whatever your level of prior experience. A particular target is to provide an accessible introduction for those new to the area.
1.1. System-on-Chip with Zynq
Given that we have already described Zynq as a System-on-Chip, an obvious first question would be “What is an SoC?”.
As you may be aware, the concept has been around for a while; the implication is that a single silicon chip can be used to implement the functionality of an entire system, rather than several different physical chips being required. In the past, the term SoC has usually referred to an Application Specific Integrated Circuit (ASIC), which can include digital, analogue and radio frequency components, together with mixed signal blocks for implementing analogue-to-digital and digital-to-analogue converters (ADCs and DACs). Focussing on the digital aspect for a moment, an SoC can combine all aspects of a digital system: processing, high-speed logic, interfacing, memory, and so on. All of these functions might otherwise be realised using physically separate devices, and combined together into a system at the Printed Circuit Board (PCB) level. The SoC solution is lower cost, enables faster and more secure data transfers between the various system elements, has higher overall system speed, lower power consumption, smaller physical size, and better reliability. In fact there are a number of compelling reasons for preferring SoCs over discrete component equivalent systems! For a simple graphical comparison of the system-on-a-board and the system-on-chip, consider Figure 1.1.
The major disadvantages of ASIC-based SoCs are (i) development time and cost, and (ii) lack of flexibility. The non-recurring engineering effort (and cost) of developing an ASIC are significant, making this type of SoC suitable only for high-volume markets where there is no requirement for future upgrades. Representative examples of ASIC-based SoCs are the integrated processors found in PCs, tablets, and smartphones; these typically comprise at least two processor cores, memory, graphics, interfacing, and other functions [4], and are manufactured in high volume for products with a limited lifetime.
The limitations of ASIC SoCs render them incompatible with a significant number of applications, particularly where fast time-to-market, flexibility, and upgrade-ability are of key importance. They also constitute a poor solution for low or medium volume markets. There is a clear need for a more flexible solution, and this is what motivates the System-on- Progammable-Chip, a specific flavour of SoC implemented on a programmable, reconfigurable device. The natural solution has long been the FPGA. FPGAs are inherently flexible devices that can be configured to implement any arbitrary system, including embedded processors if needed. FPGAs can also be reconfigured as often as desired, thus offering a more fundamentally flexible platform than ASICs for implementing SoCs. There is virtually no risk in deploying an FPGA in applications where system upgrades are required.
Now, Zynq provides an even more ideal platform for implementing flexible SoCs: Xilinx markets the device as an ‘All-Programmable SoC’ (APSoC), which perfectly captures its capabilities. The Zynq architecture will be presented in detail in Chapter 2, but first it is useful to introduce a high level model of its architecture (Figure 1.2). Note that Zynq comprises two main parts: a Processing System (PS) formed around a dual-core ARM Cortex-A9 processor, and Programmable Logic (PL), which is equivalent to that of an FPGA. It also features integrated memory, a variety of peripherals, and high-speed communications interfaces.
The PL section is ideal for implementing high-speed logic, arithmetic and data flow subsystems, while the PS supports software routines and/or operating systems, meaning that the overall functionality of any designed system can be appropriately partitioned between hardware and software. Links between the PL and PS are made using industry standard Advanced eXtensible Interface (AXI) connections [8]. Further details of each of these features will be presented as the book progresses.
1.2. Simple Anatomy of an Embedded SoC
At this early stage, it is useful to set out a basic model for the types of digital systems to be discussed in this book. These will be systems incorporating a processor, memories, and peripherals, along with buses connecting the various elements together. (This represents the hardware system, and here we consider a very simplified architecture — more details will be added in later chapters.) This model of the hardware system is shown in Figure 1.3.
The processor can be regarded as the central element of the hardware system. The software system (a software ‘stack’) is run on the processor, comprising applications (usually based on an Operating System (OS)), and with a lower layer of software functionality for interfacing with the hardware system. Communication between system elements takes place via interconnections. These may be in the style of direct, point-to-point links, or buses serving multiple components. In the latter case, a protocol is required to manage access to the bus. Note that, although a single bus with connected peripherals is shown in Figure 1.3, a processor may serve several connected buses.
Peripherals are functional components residing away from the processor, and in general these perform one of three functions: (i) coprocessors — elements that supplement the primary processor, usually optimised for a certain task; (ii) cores for interacting with external interfaces, e.g. connecting to LEDs and switches, codecs, etc.; and (iii) additional memory elements. Later in the book, we will consider peripherals in more detail, but at this point it is useful to regard them as discrete functional blocks that can be designed, tested and integrated into a system, and also ‘packaged’ for later reuse.
Figure 1.4 provides a view of the hardware system shown in Figure 1.3, mapped to the Zynq device (depicted in Figure 1.2). The architectures of both have been substantially simplified, but the objective at this stage is to provide a high level clarification of how embedded SoCs map to Zynq devices. The PS has a fixed architecture and hosts the processor and system memory, whereas the PL is completely flexible, giving the designer a ‘blank canvas’ to create custom peripherals, or to reuse standard ones. The interconnections are implemented via AXI interfaces linking the PS and PL.
The software system can also be seen on the left hand side of Figure 1.4. Software is hosted on the processor, which here is the ARM Cortex-A9, residing within the Zynq PS. It comprises a hierarchy of software elements, and this aspect will also be expanded upon later in the book.
1.3. Design Reuse
The development of a complete embedded system is a significant design task, and there are particular advantages to undertaking the design on a platform such as an FPGA or Zynq device, which make the process more straightforward. The underlying PL hardware is structured, and its performance characteristics are well known and integrated into the software development tools. Moreover, given this stable, common development platform, there is huge scope for design reuse. Intellectual Property (IP) functional blocks — corresponding to the peripheral components seen in Figure 1.4 — can be sourced from Xilinx libraries (provided with the design tools), reused from previous projects, or brought in from third parties or open source repositories, before being integrated together to form the system design.
Zynq is an SoC, and a wide variety of standard IP is available, meaning that there is no need to redesign these components. By raising the abstraction level in this way, and reusing components in the form of pre-tested and verified IP, development can be accelerated and costs can be lowered. As the popular saying goes, “Why reinvent the wheel?”.
Given its importance to the SoC design philosophy, one of the key themes of this book will be design reuse. We will consider the various sources of IP, including Xilinx libraries, mechanisms for generating one’s own IP, and sources of third party IP. Of course, it is not enough simply to attain these blocks — they must also be integrated into the system and appropriate connections and interactions established; therefore we also discuss the specific tools and methods required for this IP integration aspect of the design process. Finally, with a view to reuse and sharing of design elements, the ‘packaging’ of IP into the industry standard IP-XACT format will also be covered. These topics are the focus of Chapters 13 and 18, respectively.
1.4. Raising the Abstraction Level
A recurring trend in various software and hardware design processes is that of raising the level of abstraction. The motivation is clear: if the designer can effectively create systems with a lower requirement for explicit design input, while also supporting robust test processes, then there is great potential to accelerate the design process.
In terms of FPGA and Zynq design, advances in High Level Synthesis (HLS) mean that designers can create system components by specifying them using less detail than traditional, Register Transfer Level (RTL) methods, and instead rely upon the design tools to infer logic and optimise where possible, in accordance with user-supplied direction. Naturally this places a degree of trust in the development tools, which must be robust and produce repeatable and reliable designs. To meet this need, Xilinx has introduced the Vivado HLS tool, a high level synthesis development tool which specifically targets Xilinx devices. We will introduce Vivado HLS and associated design methods later in the book.
1.5. SoC Design Flow
A multitude of different models have been proposed for the SoC design flow with varying levels of complexity, but initially we aim to define the design flow for SoC development (as applied to Zynq) in very simple terms. The basic stages are shown in Figure 1.5.
Each of these will be expanded upon and discussed in greater detail later in the book, but a brief definition will suffice for now.
Naturally, as in any design project, the first stage is to define the desired behaviours of the system, i.e. to create an appropriate specification from a set of requirements. This is depicted as the starting point at the top of the diagram, and it forms the basis of the system design that is subsequently developed.
As mentioned earlier in this chapter, the Zynq architecture combines an ARM processor (for software elements of the designed system) with FPGA fabric (predominantly for hardware elements of the system, although additional processors can also be implemented here too, if desired). A key element of the system design stage, which comes next, is therefore to partition the intended functionality appropriately between software and hardware, and to define the interfaces between the two sections. Of course, it is possible that this partitioning will subsequently be adjusted as the designers iterate the system towards completion.
Having partitioned the system, software and hardware development can then progress in parallel, to a large extent. In terms of hardware development, the task is to identify the necessary functional blocks to achieve the design, and to thereafter assemble them through some combination of design reuse and new IP development, and make appropriate connections between the blocks. Similarly, the software aspect of the project can be realised through developing custom code or by reusing pre-existing software. Verification of both software and hardware will be required, and this forms an integral and important part of the process.
Lastly, the hardware and software elements of the system must be integrated according to the interfaces defined at the specification stage, and further ‘whole system’ testing undertaken.
The design flow will be discussed further in Chapter 3, and Zynq-based SoC design in Chapters 10 and 11.
1.6. Practical Elements
This book indirectly features a set of practical exercises that can be followed alongside the main text. Detailed instructions and all necessary resource files for these are hosted on a companion website, while the book itself includes a concise overview of each exercise, confirming its purpose and the key points of note. The detailed instructions on the web are updated asynchronously to the book, in order to maintain compatibility with the latest releases of Xilinx development tools.
The exercises can be followed with the aid of the Xilinx Vivado Design Suite (the free WebPACK® edition or higher [9]), and the Zynq-based ZedBoard [11]. It is also possible to interpret the instructions for an alternative board, if you prefer. Should you already have them, the more fully specified Xilinx Embedded or System editions of Vivado would offer enhanced functionality, but WebPACK provides sufficient facilities to get started.
The ZedBoard is shown in Figure 1.6, and this is a good, representative example of a Zynq development board [11]. There are several Zynq boards available and, like this one, most provide a variety of peripheral interfaces and connectors including ethernet, audio and video. The availability of IP blocks and reference designs supporting these features makes it relatively quick and simple to create first interactive designs. Selected Zynq boards are introduced in Chapter 3, with further details of the ZedBoard provided in Chapter 6.
1.7. About This Book
This book provides both descriptive and hands-on introductions to working with the Zynq APSoC. Most of the chapters are standard chapters (“for reading”) while there are also some others which relate to practical exercises (“for doing”). Within the book itself, we provide a short overview of each practical element, while detailed instructions and resource files are provided on a companion website [12]. This approach is intended to be more convenient, and to permit the detailed, tool-dependent instructions to be updated in response to revisions of the Xilinx software development tools, and asynchronously to the book.
The remainder of the book is organised into three, themed sections as follows:
Part A provides introductory information about the Zynq device, its associated toolflow, and the ZedBoard. Furthermore, Zynq is compared with alternative devices, and applications are explored. Part A also includes a dedicated section on Zynq and associated SoC concepts in the context of research, university-based teaching, and training catering for the general community.
Part B is an in-depth review covering various aspects of the Xilinx SoC development using Zynq. It includes concepts of embedded systems design, IP block creation and integration, and software-hardware codesign. There is also a special ‘spotlight’ chapter, focussing on the increasingly important area of HLS for rapid development of IP.
Part C focuses on OSs for Zynq SoC development. Applications, motivations, trade-offs, OS alternatives, and features are all reviewed and discussed. Further, there is an in-depth look at the practical issues of deploying Linux on Zynq, and thus forming an embedded system in combination with PL-based elements.
There is also a Glossary and List of Acronyms at the back of this book. A large number of terms and acronyms are used, and these should provide useful references.
Next we continue to Chapter 2, in which a more detailed introduction to the Zynq device architecture is provided.